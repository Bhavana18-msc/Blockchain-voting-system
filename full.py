# -*- coding: utf-8 -*-
"""full.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16a1DvlErfqdYI9U_2cMsP8p7FUIW2Xfj
"""

pip install cryptography
import hashlib
import json
import time
from cryptography.fernet import Fernet
import uuid

# Encryption key setup
key = Fernet.generate_key()
cipher = Fernet(key)

# Blockchain and vote storage
blockchain = []
voter_db = {}
vote_tokens = {}

# Initialize the blockchain
def create_genesis_block():
    return {
        'index': 0,
        'timestamp': str(time.time()),
        'data': "Genesis Block",
        'previous_hash': "0",
        'hash': hashlib.sha256("Genesis Block".encode()).hexdigest()
    }

blockchain.append(create_genesis_block())

# Register a voter
def register_voter(voter_name, voter_id):
    if voter_id in voter_db:
        return False, "Voter ID already registered!"
    encrypted_name = cipher.encrypt(voter_name.encode()).decode()
    voter_db[voter_id] = encrypted_name
    return True, f"Voter '{voter_name}' registered successfully!"

# Generate voting tokens
def generate_tokens():
    for voter_id in voter_db:
        if voter_id not in vote_tokens:
            vote_tokens[voter_id] = str(uuid.uuid4())
    return vote_tokens

# Cast a vote
def cast_vote(voter_id, token, candidate):
    if voter_id not in voter_db:
        return False, "Voter ID not found!"
    if vote_tokens.get(voter_id) != token:
        return False, "Invalid or already used voting token!"

    encrypted_vote = cipher.encrypt(candidate.encode()).decode()
    previous_block = blockchain[-1]
    new_block = {
        'index': len(blockchain),
        'timestamp': str(time.time()),
        'data': {
            'voter_id': voter_id,
            'vote': encrypted_vote
        },
        'previous_hash': previous_block['hash'],
    }
    new_block['hash'] = hashlib.sha256(json.dumps(new_block, sort_keys=True).encode()).hexdigest()
    blockchain.append(new_block)
    del vote_tokens[voter_id]
    return True, f"Vote for '{candidate}' cast successfully!"

# Validate blockchain integrity
def audit_blockchain():
    for i in range(1, len(blockchain)):
        current_block = blockchain[i]
        previous_block = blockchain[i - 1]
        if current_block['previous_hash'] != previous_block['hash']:
            return False
    return True


import time
from cryptography.fernet import Fernet
import uuid

# Encryption key setup
key = Fernet.generate_key()
cipher = Fernet(key)

# Blockchain and vote storage
blockchain = []
voter_db = {}
vote_tokens = {}

# Initialize the blockchain
def create_genesis_block():
    return {
        'index': 0,
        'timestamp': str(time.time()),
        'data': "Genesis Block",
        'previous_hash': "0",
        'hash': hashlib.sha256("Genesis Block".encode()).hexdigest()
    }

blockchain.append(create_genesis_block())

# Register a voter
def register_voter(voter_name, voter_id):
    if voter_id in voter_db:
        return False, "Voter ID already registered!"
    encrypted_name = cipher.encrypt(voter_name.encode()).decode()
    voter_db[voter_id] = encrypted_name
    return True, f"Voter '{voter_name}' registered successfully!"

# Generate voting tokens
def generate_tokens():
    for voter_id in voter_db:
        if voter_id not in vote_tokens:
            vote_tokens[voter_id] = str(uuid.uuid4())
    return vote_tokens

# Cast a vote
def cast_vote(voter_id, token, candidate):
    if voter_id not in voter_db:
        return False, "Voter ID not found!"
    if vote_tokens.get(voter_id) != token:
        return False, "Invalid or already used voting token!"

    encrypted_vote = cipher.encrypt(candidate.encode()).decode()
    previous_block = blockchain[-1]
    new_block = {
        'index': len(blockchain),
        'timestamp': str(time.time()),
        'data': {
            'voter_id': voter_id,
            'vote': encrypted_vote
        },
        'previous_hash': previous_block['hash'],
    }
    new_block['hash'] = hashlib.sha256(json.dumps(new_block, sort_keys=True).encode()).hexdigest()
    blockchain.append(new_block)
    del vote_tokens[voter_id]
    return True, f"Vote for '{candidate}' cast successfully!"

# Validate blockchain integrity
def audit_blockchain():
    for i in range(1, len(blockchain)):
        current_block = blockchain[i]
        previous_block = blockchain[i - 1]
        if current_block['previous_hash'] != previous_block['hash']:
            return False
    return True

###################################
pip install streamlit
import streamlit as st

# Streamlit Page Configuration
st.set_page_config(
    page_title="Blockchain Voting System",
    page_icon="üó≥Ô∏è",
    layout="wide",
)

# Streamlit User Interface
st.title("Blockchain Voting System")
st.subheader("Ensuring Transparent, Secure, and Efficient Elections")

# Voter Registration
st.markdown("### üìù Voter Registration")
with st.form("voter_registration_form"):
    voter_name = st.text_input("Enter Your Full Name")
    voter_id = st.text_input("Enter Your Voter ID")
    submit_registration = st.form_submit_button("Register Voter")
    if submit_registration:
        success, message = register_voter(voter_name, voter_id)
        if success:
            st.success(message)
        else:
            st.error(message)

# Token Generation
st.markdown("### üîë Generate Voting Tokens")
if st.button("Generate Tokens"):
    tokens = generate_tokens()
    if tokens:
        st.success("Voting tokens generated successfully!")
        st.json(tokens)
    else:
        st.warning("No voters registered yet!")

# Cast Vote
st.markdown("### üó≥Ô∏è Cast Your Vote")
with st.form("voting_form"):
    voter_id = st.text_input("Enter Your Voter ID")
    token = st.text_input("Enter Your Voting Token")
    candidate = st.text_input("Enter Candidate's Name")
    submit_vote = st.form_submit_button("Submit Vote")
    if submit_vote:
        success, message = cast_vote(voter_id, token, candidate)
        if success:
            st.success(message)
        else:
            st.error(message)

# Monitor and Audit Blockchain
st.markdown("### üìä Election Monitoring & Auditing")
with st.expander("View Blockchain"):
    st.json(blockchain)

with st.expander("Audit Blockchain"):
    is_valid = audit_blockchain()
    if is_valid:
        st.success("Blockchain is valid and secure.")
    else:
        st.error("Blockchain integrity compromised!")

streamlit run app.py
